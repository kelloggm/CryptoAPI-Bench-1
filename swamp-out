<?xml version="1.0" encoding="UTF-8"?>

<AnalyzerReport tool_version="3.1.12" assess_fw_version="2.6.13" build_root_dir="/home/builder/build" package_name="CryptoAPI-bench-2020" package_version="1.10000000000000008882" platform_name="ubuntu-16.04-64" assess_fw="java-assess" results_root_dir="/home/builder/results" uuid="c7d769bc-d965-45b2-b584-22d3f5333443" parser_fw="resultparser" assessment_start_ts="1587921979.4465175" package_root_dir="pkg1" parser_fw_version="3.2.3" tool_name="spotbugs">
  <BugInstance id="0">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABICase10</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABICase10.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>32</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[1]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="1">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABICase5</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABICase5.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>41</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[2]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="2">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABICase6</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABICase6.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>32</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[3]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="3">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABICase7</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABICase7.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>32</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[4]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="4">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABICase8</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABICase8.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>32</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[5]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="5">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[6]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="6">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase1.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[7]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="7">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>327</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>DES_USAGE</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>DES should be replaced with AES</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage of AES block ciphers instead of DES. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Example weak code:&lt;/b&gt; &lt;pre&gt;Cipher c = Cipher.getInstance("DES/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Example solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://www.nist.gov/itl/fips/060205_des.cfm"&gt;NIST Withdraws Outdated Data Encryption Standard&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/326.html"&gt;CWE-326: Inadequate Encryption Strength&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[8]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="8">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>327</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>ECB_MODE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher uses ECB mode, which provides poor confidentiality for encrypted data</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;An authentication cipher mode which provides better confidentiality of the encrypted data should be used instead of Electronic Code Book (ECB) mode, which does not provide good confidentiality. Specifically, ECB mode produces the same output for the same input each time. So,  for example, if a user is sending a password, the encrypted value is the same each time. This allows an attacker to intercept  and replay the data.&lt;/p&gt; &lt;p&gt; To fix this, something like Galois/Counter Mode (GCM) should be used instead. &lt;/p&gt; &lt;p&gt; &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/ECB/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29"&gt;Wikipedia: Block cipher modes of operation&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf"&gt;NIST: Recommendation for Block Cipher Modes of Operation&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[9]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="9">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase1.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[10]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="10">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase2.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[11]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="11">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase2.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[12]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="12">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase2.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[13]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="13">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase3.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[14]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="14">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase3.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[15]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="15">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase3.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[16]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="16">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase4.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[17]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="17">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase4.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[18]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="18">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase4.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[19]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="19">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase5</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase5.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[20]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="20">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase5</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase5.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[21]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="21">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoABPSCase5</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoABPSCase5.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[22]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="22">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[23]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="23">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase1.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <CweId>327</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>DES_USAGE</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>DES should be replaced with AES</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage of AES block ciphers instead of DES. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Example weak code:&lt;/b&gt; &lt;pre&gt;Cipher c = Cipher.getInstance("DES/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Example solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://www.nist.gov/itl/fips/060205_des.cfm"&gt;NIST Withdraws Outdated Data Encryption Standard&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/326.html"&gt;CWE-326: Inadequate Encryption Strength&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[24]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="24">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>327</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>DES_USAGE</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>DES should be replaced with AES</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; DES is considered strong ciphers for modern applications. Currently, NIST recommends the usage of AES block ciphers instead of DES. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Example weak code:&lt;/b&gt; &lt;pre&gt;Cipher c = Cipher.getInstance("DES/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Example solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://www.nist.gov/itl/fips/060205_des.cfm"&gt;NIST Withdraws Outdated Data Encryption Standard&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/326.html"&gt;CWE-326: Inadequate Encryption Strength&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[25]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="25">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>327</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>ECB_MODE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher uses ECB mode, which provides poor confidentiality for encrypted data</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;An authentication cipher mode which provides better confidentiality of the encrypted data should be used instead of Electronic Code Book (ECB) mode, which does not provide good confidentiality. Specifically, ECB mode produces the same output for the same input each time. So,  for example, if a user is sending a password, the encrypted value is the same each time. This allows an attacker to intercept  and replay the data.&lt;/p&gt; &lt;p&gt; To fix this, something like Galois/Counter Mode (GCM) should be used instead. &lt;/p&gt; &lt;p&gt; &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/ECB/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29"&gt;Wikipedia: Block cipher modes of operation&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf"&gt;NIST: Recommendation for Block Cipher Modes of Operation&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[26]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="26">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase2.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[27]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="27">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase3.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[28]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="28">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase4.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[29]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="29">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoBBCase5</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoBBCase5.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[30]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="30">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoCorrected.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[31]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="31">
    <ClassName>org.cryptoapi.bench.brokencrypto.BrokenCryptoCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokencrypto/BrokenCryptoCorrected.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[32]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="32">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase1.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[33]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="33">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase1.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[34]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="34">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase1.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[35]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="35">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase10</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase10.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase10.method1(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[36]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="36">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase10</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase10.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase10.method1(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[37]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="37">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase10</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase10.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase10.method1(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[38]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="38">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase11</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase11.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase11.method1(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[39]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="39">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase11</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase11.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase11.method1(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[40]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="40">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase11</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase11.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase11.method1(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[41]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="41">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase12</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase12.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase12.method1(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[42]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="42">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase12</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase12.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase12.method1(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[43]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="43">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase12</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase12.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase12.method1(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[44]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="44">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase2.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase2.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[45]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="45">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase2.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase2.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[46]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="46">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase2.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase2.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[47]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="47">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase3.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase3.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[48]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="48">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase3.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase3.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[49]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="49">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase3.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase3.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[50]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="50">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase4.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase4.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[51]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="51">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase4.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase4.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[52]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="52">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase4.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase4.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[53]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="53">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase5</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase5.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase5.go(String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[54]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="54">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase5</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase5.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase5.go(String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[55]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="55">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase5</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase5.java</SourceFile>
        <StartLine>6</StartLine>
        <EndLine>28</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[56]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="56">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase5</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase5.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase5.go(String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[57]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="57">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase6</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase6.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase6.go(String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[58]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="58">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase6</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase6.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase6.go(String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[59]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="59">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase6</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase6.java</SourceFile>
        <StartLine>6</StartLine>
        <EndLine>28</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[60]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="60">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase6</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase6.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase6.go(String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[61]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="61">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase7</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase7.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase7.go(String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[62]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="62">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase7</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase7.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase7.go(String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[63]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="63">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase7</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase7.java</SourceFile>
        <StartLine>6</StartLine>
        <EndLine>28</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[64]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="64">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase7</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase7.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase7.go(String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[65]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="65">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase8</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase8.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase8.go(String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[66]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="66">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase8</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase8.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase8.go(String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[67]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="67">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase8</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase8.java</SourceFile>
        <StartLine>6</StartLine>
        <EndLine>28</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[68]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="68">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase8</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase8.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase8.go(String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[69]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="69">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase9</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase9.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABICase9.method1(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[70]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="70">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase9</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase9.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABICase9.method1(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[71]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="71">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABICase9</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABICase9.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABICase9.method1(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[72]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="72">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABMC1.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[73]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="73">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABMC1.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[74]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="74">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABMC1.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[75]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="75">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABMC2.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[76]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="76">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC2.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABMC2.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[77]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="77">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC2.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABMC2.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[78]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="78">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC3.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABMC3.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[79]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="79">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC3.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABMC3.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[80]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="80">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC3</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC3.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABMC3.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[81]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="81">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC4.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABMC4.go(String, String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[82]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="82">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC4.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABMC4.go(String, String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[83]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="83">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABMC4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABMC4.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABMC4.go(String, String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[84]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="84">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase1.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase1.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[85]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="85">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase1.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase1.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[86]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="86">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase1.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABPSCase1.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[87]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="87">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_SHA1</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>SHA1 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms SHA-1 is not a recommended algorithm for hash password, for signature verification and other uses. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-1 for digital signature generation:&lt;/b&gt;&lt;br/&gt;     SHA-1 may only be used for digital signature generation where specifically allowed by NIST protocol-specific guidance.     For all other applications, &lt;u&gt;SHA-1 shall not be used for digital signature generation&lt;/u&gt;.&lt;br/&gt;     &lt;b&gt;SHA-1 for digital signature verification:&lt;/b&gt;&lt;br/&gt;     For digital signature verification, &lt;u&gt;SHA-1 is allowed for legacy-use&lt;/u&gt;.&lt;br/&gt;     [...]&lt;br/&gt;     &lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt;  &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest sha1Digest = MessageDigest.getInstance("SHA1");     sha1Digest.update(password.getBytes());     byte[] hashValue = sha1Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://community.qualys.com/blogs/securitylabs/2014/09/09/sha1-deprecation-what-you-need-to-know"&gt;Qualys blog: SHA1 Deprecation: What You Need to Know&lt;/a&gt;&lt;br/&gt; &lt;a href="https://googleonlinesecurity.blogspot.ca/2014/09/gradually-sunsetting-sha-1.html"&gt;Google Online Security Blog: Gradually sunsetting SHA-1&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[88]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="88">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase2.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase2.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[89]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="89">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase2.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase2.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[90]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="90">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase2.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABPSCase2.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[91]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="91">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase2.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_MD5</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>MD5 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms MD2, MD4 and MD5 are not a recommended MessageDigest. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "The security of the MD5 hash function is severely compromised. A collision attack exists that can find collisions     within seconds on a computer with a 2.6 GHz Pentium 4 processor (complexity of 2&lt;sup&gt;24.1&lt;/sup&gt;).[1] Further, there is also a     chosen-prefix collision attack that can produce a collision for two inputs with specified prefixes within hours, using     off-the-shelf computing hardware (complexity 2&lt;sup&gt;39&lt;/sup&gt;).[2]"&lt;br/&gt;     - &lt;a href="https://en.wikipedia.org/wiki/MD5#Security"&gt;Wikipedia: MD5 - Security&lt;/a&gt; &lt;/blockquote&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt; &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest md5Digest = MessageDigest.getInstance("MD5");     md5Digest.update(password.getBytes());     byte[] hashValue = md5Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; [1] &lt;a href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf"&gt;On Collisions for MD5&lt;/a&gt;: Master Thesis by M.M.J. Stevens&lt;br/&gt; [2] &lt;a href="http://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf"&gt;Chosen-prefix collisions for MD5 and applications&lt;/a&gt;: Paper written by Marc Stevens&lt;br/&gt; &lt;a href="https://en.wikipedia.org/wiki/MD5"&gt;Wikipedia: MD5&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[92]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="92">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase3.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase3.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[93]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="93">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase3.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase3.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[94]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="94">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase3.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABPSCase3.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[95]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="95">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase3.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_MD5</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>MD4 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms MD2, MD4 and MD5 are not a recommended MessageDigest. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "The security of the MD5 hash function is severely compromised. A collision attack exists that can find collisions     within seconds on a computer with a 2.6 GHz Pentium 4 processor (complexity of 2&lt;sup&gt;24.1&lt;/sup&gt;).[1] Further, there is also a     chosen-prefix collision attack that can produce a collision for two inputs with specified prefixes within hours, using     off-the-shelf computing hardware (complexity 2&lt;sup&gt;39&lt;/sup&gt;).[2]"&lt;br/&gt;     - &lt;a href="https://en.wikipedia.org/wiki/MD5#Security"&gt;Wikipedia: MD5 - Security&lt;/a&gt; &lt;/blockquote&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt; &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest md5Digest = MessageDigest.getInstance("MD5");     md5Digest.update(password.getBytes());     byte[] hashValue = md5Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; [1] &lt;a href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf"&gt;On Collisions for MD5&lt;/a&gt;: Master Thesis by M.M.J. Stevens&lt;br/&gt; [2] &lt;a href="http://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf"&gt;Chosen-prefix collisions for MD5 and applications&lt;/a&gt;: Paper written by Marc Stevens&lt;br/&gt; &lt;a href="https://en.wikipedia.org/wiki/MD5"&gt;Wikipedia: MD5&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[96]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="96">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase4.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase4.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[97]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="97">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase4.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashABPSCase4.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[98]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="98">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase4.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashABPSCase4.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[99]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="99">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashABPSCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashABPSCase4.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_MD5</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>MD2 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms MD2, MD4 and MD5 are not a recommended MessageDigest. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "The security of the MD5 hash function is severely compromised. A collision attack exists that can find collisions     within seconds on a computer with a 2.6 GHz Pentium 4 processor (complexity of 2&lt;sup&gt;24.1&lt;/sup&gt;).[1] Further, there is also a     chosen-prefix collision attack that can produce a collision for two inputs with specified prefixes within hours, using     off-the-shelf computing hardware (complexity 2&lt;sup&gt;39&lt;/sup&gt;).[2]"&lt;br/&gt;     - &lt;a href="https://en.wikipedia.org/wiki/MD5#Security"&gt;Wikipedia: MD5 - Security&lt;/a&gt; &lt;/blockquote&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt; &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest md5Digest = MessageDigest.getInstance("MD5");     md5Digest.update(password.getBytes());     byte[] hashValue = md5Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; [1] &lt;a href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf"&gt;On Collisions for MD5&lt;/a&gt;: Master Thesis by M.M.J. Stevens&lt;br/&gt; [2] &lt;a href="http://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf"&gt;Chosen-prefix collisions for MD5 and applications&lt;/a&gt;: Paper written by Marc Stevens&lt;br/&gt; &lt;a href="https://en.wikipedia.org/wiki/MD5"&gt;Wikipedia: MD5&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[100]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="100">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase1.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashBBCase1.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[101]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="101">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashBBCase1.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[102]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="102">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashBBCase1.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[103]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="103">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_SHA1</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>SHA1 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms SHA-1 is not a recommended algorithm for hash password, for signature verification and other uses. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-1 for digital signature generation:&lt;/b&gt;&lt;br/&gt;     SHA-1 may only be used for digital signature generation where specifically allowed by NIST protocol-specific guidance.     For all other applications, &lt;u&gt;SHA-1 shall not be used for digital signature generation&lt;/u&gt;.&lt;br/&gt;     &lt;b&gt;SHA-1 for digital signature verification:&lt;/b&gt;&lt;br/&gt;     For digital signature verification, &lt;u&gt;SHA-1 is allowed for legacy-use&lt;/u&gt;.&lt;br/&gt;     [...]&lt;br/&gt;     &lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt;  &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest sha1Digest = MessageDigest.getInstance("SHA1");     sha1Digest.update(password.getBytes());     byte[] hashValue = sha1Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://community.qualys.com/blogs/securitylabs/2014/09/09/sha1-deprecation-what-you-need-to-know"&gt;Qualys blog: SHA1 Deprecation: What You Need to Know&lt;/a&gt;&lt;br/&gt; &lt;a href="https://googleonlinesecurity.blogspot.ca/2014/09/gradually-sunsetting-sha-1.html"&gt;Google Online Security Blog: Gradually sunsetting SHA-1&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[104]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="104">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase2.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashBBCase2.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[105]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="105">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashBBCase2.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[106]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="106">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashBBCase2.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[107]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="107">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase2.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_MD5</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>MD5 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms MD2, MD4 and MD5 are not a recommended MessageDigest. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "The security of the MD5 hash function is severely compromised. A collision attack exists that can find collisions     within seconds on a computer with a 2.6 GHz Pentium 4 processor (complexity of 2&lt;sup&gt;24.1&lt;/sup&gt;).[1] Further, there is also a     chosen-prefix collision attack that can produce a collision for two inputs with specified prefixes within hours, using     off-the-shelf computing hardware (complexity 2&lt;sup&gt;39&lt;/sup&gt;).[2]"&lt;br/&gt;     - &lt;a href="https://en.wikipedia.org/wiki/MD5#Security"&gt;Wikipedia: MD5 - Security&lt;/a&gt; &lt;/blockquote&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt; &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest md5Digest = MessageDigest.getInstance("MD5");     md5Digest.update(password.getBytes());     byte[] hashValue = md5Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; [1] &lt;a href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf"&gt;On Collisions for MD5&lt;/a&gt;: Master Thesis by M.M.J. Stevens&lt;br/&gt; [2] &lt;a href="http://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf"&gt;Chosen-prefix collisions for MD5 and applications&lt;/a&gt;: Paper written by Marc Stevens&lt;br/&gt; &lt;a href="https://en.wikipedia.org/wiki/MD5"&gt;Wikipedia: MD5&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[108]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="108">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase3.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashBBCase3.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[109]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="109">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase3.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashBBCase3.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[110]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="110">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase3.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashBBCase3.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[111]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="111">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase3.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_MD5</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>MD4 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms MD2, MD4 and MD5 are not a recommended MessageDigest. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "The security of the MD5 hash function is severely compromised. A collision attack exists that can find collisions     within seconds on a computer with a 2.6 GHz Pentium 4 processor (complexity of 2&lt;sup&gt;24.1&lt;/sup&gt;).[1] Further, there is also a     chosen-prefix collision attack that can produce a collision for two inputs with specified prefixes within hours, using     off-the-shelf computing hardware (complexity 2&lt;sup&gt;39&lt;/sup&gt;).[2]"&lt;br/&gt;     - &lt;a href="https://en.wikipedia.org/wiki/MD5#Security"&gt;Wikipedia: MD5 - Security&lt;/a&gt; &lt;/blockquote&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt; &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest md5Digest = MessageDigest.getInstance("MD5");     md5Digest.update(password.getBytes());     byte[] hashValue = md5Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; [1] &lt;a href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf"&gt;On Collisions for MD5&lt;/a&gt;: Master Thesis by M.M.J. Stevens&lt;br/&gt; [2] &lt;a href="http://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf"&gt;Chosen-prefix collisions for MD5 and applications&lt;/a&gt;: Paper written by Marc Stevens&lt;br/&gt; &lt;a href="https://en.wikipedia.org/wiki/MD5"&gt;Wikipedia: MD5&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[112]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="112">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">digest</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase4.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on java.security.MessageDigest.digest() in org.cryptoapi.bench.brokenhash.BrokenHashBBCase4.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[113]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="113">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase4.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.brokenhash.BrokenHashBBCase4.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[114]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="114">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase4.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashBBCase4.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[115]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="115">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashBBCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashBBCase4.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <CweId>328</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>WEAK_MESSAGE_DIGEST_MD5</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>MD2 is not a recommended cryptographic hash function</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;The algorithms MD2, MD4 and MD5 are not a recommended MessageDigest. &lt;b&gt;PBKDF2&lt;/b&gt; should be used to hash password for example.&lt;/p&gt;  &lt;blockquote&gt;     "The security of the MD5 hash function is severely compromised. A collision attack exists that can find collisions     within seconds on a computer with a 2.6 GHz Pentium 4 processor (complexity of 2&lt;sup&gt;24.1&lt;/sup&gt;).[1] Further, there is also a     chosen-prefix collision attack that can produce a collision for two inputs with specified prefixes within hours, using     off-the-shelf computing hardware (complexity 2&lt;sup&gt;39&lt;/sup&gt;).[2]"&lt;br/&gt;     - &lt;a href="https://en.wikipedia.org/wiki/MD5#Security"&gt;Wikipedia: MD5 - Security&lt;/a&gt; &lt;/blockquote&gt;  &lt;blockquote&gt;     "&lt;b&gt;SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256&lt;/b&gt;:&lt;br/&gt;     The use of these hash functions is acceptable for all hash function applications."&lt;br/&gt;     - &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.15&lt;/a&gt; &lt;/blockquote&gt; &lt;blockquote&gt;     "The main idea of a PBKDF is to slow dictionary or brute force attacks on the passwords by increasing the time     needed to test each password. An attacker with a list of likely passwords can evaluate the PBKDF using the known     iteration counter and the salt. Since an attacker has to spend a significant amount of computing time for each try,     it becomes harder to apply the dictionary or brute force attacks."&lt;br/&gt; - &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation  p.12&lt;/a&gt; &lt;/blockquote&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;MessageDigest md5Digest = MessageDigest.getInstance("MD5");     md5Digest.update(password.getBytes());     byte[] hashValue = md5Digest.digest();&lt;/pre&gt;     &lt;br/&gt;     &lt;pre&gt;byte[] hashValue = DigestUtils.getMd5Digest().digest(password.getBytes());&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;Solution (Using bouncy castle):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());     gen.init(password.getBytes("UTF-8"), salt.getBytes(), 4096);     return ((KeyParameter) gen.generateDerivedParameters(256)).getKey(); }&lt;/pre&gt;     &lt;br/&gt;     &lt;b&gt;Solution (Java 8 and later):&lt;/b&gt;&lt;br/&gt;     &lt;pre&gt;public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {     KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);     SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");     return f.generateSecret(spec).getEncoded(); }&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; [1] &lt;a href="http://www.win.tue.nl/hashclash/On%20Collisions%20for%20MD5%20-%20M.M.J.%20Stevens.pdf"&gt;On Collisions for MD5&lt;/a&gt;: Master Thesis by M.M.J. Stevens&lt;br/&gt; [2] &lt;a href="http://homepages.cwi.nl/~stevens/papers/stJOC%20-%20Chosen-Prefix%20Collisions%20for%20MD5%20and%20Applications.pdf"&gt;Chosen-prefix collisions for MD5 and applications&lt;/a&gt;: Paper written by Marc Stevens&lt;br/&gt; &lt;a href="https://en.wikipedia.org/wiki/MD5"&gt;Wikipedia: MD5&lt;/a&gt;&lt;br/&gt; &lt;a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf"&gt;NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf"&gt;NIST: Recommendation for Password-Based Key Derivation&lt;/a&gt;&lt;br/&gt; &lt;a href="https://stackoverflow.com/q/22580853/89769"&gt;Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/327.html"&gt;CWE-327: Use of a Broken or Risky Cryptographic Algorithm&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[116]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="116">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashCorrected.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Dead store to $L1 in org.cryptoapi.bench.brokenhash.BrokenHashCorrected.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[117]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="117">
    <ClassName>org.cryptoapi.bench.brokenhash.BrokenHashCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/brokenhash/BrokenHashCorrected.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>IMC_IMMATURE_CLASS_PRINTSTACKTRACE</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.brokenhash.BrokenHashCorrected.main(String[]) prints the stack trace to the console</BugMessage>
    <ResolutionSuggestion>     		     		&lt;p&gt;This method prints a stack trace to the console. This is non configurable, and causes an     		application to look unprofessional. Switch to using loggers so that users can control what     		is logged and where.&lt;/p&gt;     		     	</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[118]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="118">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoABICase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoABICase2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>32</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[119]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="119">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoABPSCase1.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[120]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="120">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoABPSCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[121]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="121">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoABPSCase1.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <CweId>327</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>ECB_MODE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher uses ECB mode, which provides poor confidentiality for encrypted data</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;An authentication cipher mode which provides better confidentiality of the encrypted data should be used instead of Electronic Code Book (ECB) mode, which does not provide good confidentiality. Specifically, ECB mode produces the same output for the same input each time. So,  for example, if a user is sending a password, the encrypted value is the same each time. This allows an attacker to intercept  and replay the data.&lt;/p&gt; &lt;p&gt; To fix this, something like Galois/Counter Mode (GCM) should be used instead. &lt;/p&gt; &lt;p&gt; &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/ECB/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29"&gt;Wikipedia: Block cipher modes of operation&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf"&gt;NIST: Recommendation for Block Cipher Modes of Operation&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[122]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="122">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoABPSCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[123]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="123">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoBBCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[124]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="124">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoBBCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>327</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>ECB_MODE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher uses ECB mode, which provides poor confidentiality for encrypted data</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;An authentication cipher mode which provides better confidentiality of the encrypted data should be used instead of Electronic Code Book (ECB) mode, which does not provide good confidentiality. Specifically, ECB mode produces the same output for the same input each time. So,  for example, if a user is sending a password, the encrypted value is the same each time. This allows an attacker to intercept  and replay the data.&lt;/p&gt; &lt;p&gt; To fix this, something like Galois/Counter Mode (GCM) should be used instead. &lt;/p&gt; &lt;p&gt; &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/ECB/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29"&gt;Wikipedia: Block cipher modes of operation&lt;/a&gt;&lt;br/&gt; &lt;a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf"&gt;NIST: Recommendation for Block Cipher Modes of Operation&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[125]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="125">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoCorrected.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[126]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="126">
    <ClassName>org.cryptoapi.bench.ecbcrypto.EcbInSymmCryptoCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/ecbcrypto/EcbInSymmCryptoCorrected.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[127]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="127">
    <ClassName>org.cryptoapi.bench.http.HttpProtocolABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/http/HttpProtocolABICase2.java</SourceFile>
        <StartLine>23</StartLine>
        <EndLine>23</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Invocation of toString on HttpProtocolABICase2.url in org.cryptoapi.bench.http.HttpProtocolABICase2.go()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[128]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="128">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABICase1.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_STRING_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase1.go(int) invokes inefficient new String(String) constructor</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; Using the &lt;code&gt;java.lang.String(String)&lt;/code&gt; constructor wastes memory   because the object so constructed will be functionally indistinguishable   from the &lt;code&gt;String&lt;/code&gt; passed as a parameter.&amp;nbsp; Just use the   argument &lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[129]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="129">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABICase1.java</SourceFile>
        <StartLine>24</StartLine>
        <EndLine>24</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS</BugCode>
    <BugRank>16</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase1.go(int) appears to call the same method on the same object redundantly</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This method makes two consecutive calls to the same method, using the same constant 			parameters, on the same instance, without any intervening changes to the objects. If this 			method does not make changes to the object, which it appears it doesn't, then making 			two calls is just a waste. These method calls could be combined by assigning the 			result into a temporary variable, and using the variable the second time.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[130]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="130">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABICase2.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_STRING_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase2.go(KeyPairGenerator, KeyPair) invokes inefficient new String(String) constructor</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; Using the &lt;code&gt;java.lang.String(String)&lt;/code&gt; constructor wastes memory   because the object so constructed will be functionally indistinguishable   from the &lt;code&gt;String&lt;/code&gt; passed as a parameter.&amp;nbsp; Just use the   argument &lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[131]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="131">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABICase2.java</SourceFile>
        <StartLine>24</StartLine>
        <EndLine>24</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS</BugCode>
    <BugRank>16</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase2.go(KeyPairGenerator, KeyPair) appears to call the same method on the same object redundantly</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This method makes two consecutive calls to the same method, using the same constant 			parameters, on the same instance, without any intervening changes to the objects. If this 			method does not make changes to the object, which it appears it doesn't, then making 			two calls is just a waste. These method calls could be combined by assigning the 			result into a temporary variable, and using the variable the second time.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[132]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="132">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABICase3.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_STRING_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase3.method1(int) invokes inefficient new String(String) constructor</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; Using the &lt;code&gt;java.lang.String(String)&lt;/code&gt; constructor wastes memory   because the object so constructed will be functionally indistinguishable   from the &lt;code&gt;String&lt;/code&gt; passed as a parameter.&amp;nbsp; Just use the   argument &lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[133]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="133">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method1</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABICase3.java</SourceFile>
        <StartLine>31</StartLine>
        <EndLine>31</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS</BugCode>
    <BugRank>16</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABICase3.method1(int) appears to call the same method on the same object redundantly</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This method makes two consecutive calls to the same method, using the same constant 			parameters, on the same instance, without any intervening changes to the objects. If this 			method does not make changes to the object, which it appears it doesn't, then making 			two calls is just a waste. These method calls could be combined by assigning the 			result into a temporary variable, and using the variable the second time.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[134]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="134">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABMC1.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_STRING_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABMC1.go(int) invokes inefficient new String(String) constructor</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; Using the &lt;code&gt;java.lang.String(String)&lt;/code&gt; constructor wastes memory   because the object so constructed will be functionally indistinguishable   from the &lt;code&gt;String&lt;/code&gt; passed as a parameter.&amp;nbsp; Just use the   argument &lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[135]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="135">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABMC1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS</BugCode>
    <BugRank>16</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABMC1.go(int) appears to call the same method on the same object redundantly</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This method makes two consecutive calls to the same method, using the same constant 			parameters, on the same instance, without any intervening changes to the objects. If this 			method does not make changes to the object, which it appears it doesn't, then making 			two calls is just a waste. These method calls could be combined by assigning the 			result into a temporary variable, and using the variable the second time.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[136]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="136">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherABPSCase1.java</SourceFile>
        <StartLine>24</StartLine>
        <EndLine>24</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_STRING_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherABPSCase1.go(int) invokes inefficient new String(String) constructor</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; Using the &lt;code&gt;java.lang.String(String)&lt;/code&gt; constructor wastes memory   because the object so constructed will be functionally indistinguishable   from the &lt;code&gt;String&lt;/code&gt; passed as a parameter.&amp;nbsp; Just use the   argument &lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[137]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="137">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherBBCase1.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_STRING_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherBBCase1.go() invokes inefficient new String(String) constructor</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; Using the &lt;code&gt;java.lang.String(String)&lt;/code&gt; constructor wastes memory   because the object so constructed will be functionally indistinguishable   from the &lt;code&gt;String&lt;/code&gt; passed as a parameter.&amp;nbsp; Just use the   argument &lt;code&gt;String&lt;/code&gt; directly.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[138]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="138">
    <ClassName>org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/insecureasymmetriccrypto/InsecureAsymmetricCipherBBCase1.java</SourceFile>
        <StartLine>23</StartLine>
        <EndLine>23</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS</BugCode>
    <BugRank>16</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.insecureasymmetriccrypto.InsecureAsymmetricCipherBBCase1.go() appears to call the same method on the same object redundantly</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This method makes two consecutive calls to the same method, using the same constant 			parameters, on the same instance, without any intervening changes to the objects. If this 			method does not make changes to the object, which it appears it doesn't, then making 			two calls is just a waste. These method calls could be combined by assigning the 			result into a temporary variable, and using the variable the second time.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[139]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="139">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
      <Method id="2" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABHCase1.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This method "String.getBytes(String)" needlessly uses a String literal to define an encoding.  A built-in Charset could be used instead like: String.getBytes(Charset)</BugMessage>
    <ResolutionSuggestion>     		     		&lt;p&gt;This method uses a string literal to specify a &lt;code&gt;Charset&lt;/code&gt; encoding. However, the method invoked has an     		alternative signature that takes a &lt;code&gt;Charset&lt;/code&gt; object. You should use this signature, as this class is compiled     		with JDK 7 (or better), and the &lt;code&gt;Charset&lt;/code&gt; in question is available as a constant from the     		&lt;code&gt;java.nio.charset.StandardCharsets&lt;/code&gt; class.&lt;/p&gt;     		&lt;p&gt;Instead of specifying "UTF-8", use &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;, for instance. An added benefit of this is     		that you will not need to catch &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt;     		     	</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[140]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="140">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABHCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase1.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[141]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="141">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABHCase2.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>BED_BOGUS_EXCEPTION_DECLARATION</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Non derivable method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2.main(String[]) declares throwing an exception that isn't thrown</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This method declares that it throws a checked exception that it does not throw. As this method is 			either a constructor, static method or private method, there is no reason for this method to declare 			the exception in its throws clause, and just causes calling methods to unnecessarily handle an exception 			that will never be thrown. The exception in question should be removed from the throws clause.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[142]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="142">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABHCase2.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[143]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="143">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABHCase2.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[144]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="144">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABHCase2.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABHCase2.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[145]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="145">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase1.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase1.go(String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[146]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="146">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase1.go(String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[147]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="147">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase1.go(String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[148]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="148">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase2.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2.go()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[149]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="149">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase2.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>8</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Invocation of toString on PredictableCryptographicKeyABICase2.encryptKey in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2.go()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[150]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="150">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase2.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2.go(): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[151]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="151">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase2.java</SourceFile>
        <StartLine>7</StartLine>
        <EndLine>28</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[152]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="152">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase2.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase2.go() encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[153]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="153">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase3.java</SourceFile>
        <StartLine>18</StartLine>
        <EndLine>18</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase3.method2(String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[154]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="154">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase3.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase3.method2(String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[155]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="155">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABICase3.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABICase3.method2(String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[156]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="156">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABMC1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABMC1.go(String)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[157]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="157">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABMC1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABMC1.go(String): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[158]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="158">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABMC1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABMC1.go(String) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[159]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="159">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABPSCase1.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[160]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="160">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABPSCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[161]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="161">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABPSCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[161]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="162">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABPSCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[162]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="163">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyABPSCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyABPSCase1.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[163]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="164">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyBBCase1.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to keySpec in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyBBCase1.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[164]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="165">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyBBCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyBBCase1.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[165]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="166">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyBBCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyBBCase1.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[166]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="167">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyCorrected.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[167]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="168">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
      <Method id="2" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyCorrected.java</SourceFile>
        <StartLine>24</StartLine>
        <EndLine>24</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This method "String.getBytes(String)" needlessly uses a String literal to define an encoding.  A built-in Charset could be used instead like: String.getBytes(Charset)</BugMessage>
    <ResolutionSuggestion>     		     		&lt;p&gt;This method uses a string literal to specify a &lt;code&gt;Charset&lt;/code&gt; encoding. However, the method invoked has an     		alternative signature that takes a &lt;code&gt;Charset&lt;/code&gt; object. You should use this signature, as this class is compiled     		with JDK 7 (or better), and the &lt;code&gt;Charset&lt;/code&gt; in question is available as a constant from the     		&lt;code&gt;java.nio.charset.StandardCharsets&lt;/code&gt; class.&lt;/p&gt;     		&lt;p&gt;Instead of specifying "UTF-8", use &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;, for instance. An added benefit of this is     		that you will not need to catch &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt;     		     	</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[168]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="169">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyCorrected.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyCorrected.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[169]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="170">
    <ClassName>org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablecryptographickey/PredictableCryptographicKeyCorrected.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablecryptographickey.PredictableCryptographicKeyCorrected.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[170]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="171">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
      <Method id="2" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase1.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This method "String.getBytes(String)" needlessly uses a String literal to define an encoding.  A built-in Charset could be used instead like: String.getBytes(Charset)</BugMessage>
    <ResolutionSuggestion>     		     		&lt;p&gt;This method uses a string literal to specify a &lt;code&gt;Charset&lt;/code&gt; encoding. However, the method invoked has an     		alternative signature that takes a &lt;code&gt;Charset&lt;/code&gt; object. You should use this signature, as this class is compiled     		with JDK 7 (or better), and the &lt;code&gt;Charset&lt;/code&gt; in question is available as a constant from the     		&lt;code&gt;java.nio.charset.StandardCharsets&lt;/code&gt; class.&lt;/p&gt;     		&lt;p&gt;Instead of specifying "UTF-8", use &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;, for instance. An added benefit of this is     		that you will not need to catch &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt;     		     	</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[171]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="172">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase1.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABHCase1.go(): new String(byte[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[172]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="173">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase1.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABHCase1.go() encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[173]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="174">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase1.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase1.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase1.java:26 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase1.java:26 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[174]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="175">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase2.java</SourceFile>
        <StartLine>31</StartLine>
        <EndLine>31</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase2.java</SourceFile>
        <StartLine>31</StartLine>
        <EndLine>31</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase2.java:31 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABHCase2.java:31 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[175]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="176">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase1.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase1.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase1.java:22 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase1.java:22 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[176]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="177">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">load</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase2.java</SourceFile>
        <StartLine>33</StartLine>
        <EndLine>33</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[177]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="178">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABICase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>34</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[178]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="179">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase2.java</SourceFile>
        <StartLine>33</StartLine>
        <EndLine>33</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase2.java</SourceFile>
        <StartLine>33</StartLine>
        <EndLine>33</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase2.java:33 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase2.java:33 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[179]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="180">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase3.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase3.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase3.java:27 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABICase3.java:27 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[180]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="181">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABMC1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABMC1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABMC1.java:17 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABMC1.java:17 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[181]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="182">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABPSCase1.java</SourceFile>
        <StartLine>28</StartLine>
        <EndLine>28</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABPSCase1.java</SourceFile>
        <StartLine>28</StartLine>
        <EndLine>28</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABPSCase1.java:28 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordABPSCase1.java:28 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[182]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="183">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">load</Method>
      <Method id="2" primary="false">toCharArray</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordBBCase1.java</SourceFile>
        <StartLine>23</StartLine>
        <EndLine>23</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[183]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="184">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordBBCase1.java</SourceFile>
        <StartLine>23</StartLine>
        <EndLine>23</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordBBCase1.java</SourceFile>
        <StartLine>23</StartLine>
        <EndLine>23</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordBBCase1.java:23 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordBBCase1.java:23 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[184]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="185">
    <ClassName>org.cryptoapi.bench.predictablekeystorepassword.PredictableKeyStorePasswordCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordCorrected.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
      <Location id="1" primary="false">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordCorrected.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <CweId>918</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>URLCONNECTION_SSRF_FD</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This web server request could be used by an attacker to expose internal services and filesystem.

Bug Path:

*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordCorrected.java:26 ****** Primary Bug Location
*** pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablekeystorepassword/PredictableKeyStorePasswordCorrected.java:26 ***
</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Server-Side Request Forgery occur when a web server executes a request to a user supplied destination     parameter that is not validated. Such vulnerabilities could allow an attacker to access internal services     or to launch attacks from your web server. &lt;/p&gt; &lt;p&gt;     URLConnection can be used with file:// protocol or other protocols to access local filesystem and potentially other services. &lt;p&gt;     &lt;b&gt;Vulnerable Code:&lt;/b&gt; &lt;pre&gt; new URL(String url).openConnection() new URL(String url).openStream() new URL(String url).getContent() &lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution/Countermeasures:&lt;/b&gt;&lt;br/&gt;     &lt;ul&gt;         &lt;li&gt;Don't accept URL destinations from users&lt;/li&gt;         &lt;li&gt;Accept a destination key, and use it to look up the target (legal) destination&lt;/li&gt;         &lt;li&gt;White list URLs (if possible)&lt;/li&gt;         &lt;li&gt;Validate that the beginning of the URL is part of a white list&lt;/li&gt;     &lt;/ul&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/918.html"&gt;CWE-918: Server-Side Request Forgery (SSRF)&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/"&gt;Understanding Server-Side Request Forgery&lt;/a&gt;&lt;br/&gt; &lt;a href="https://cwe.mitre.org/data/definitions/73.html"&gt;CWE-73: External Control of File Name or Path&lt;/a&gt;&lt;br/&gt; &lt;a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/"&gt;Abusing jar:// downloads&lt;/a&gt;&lt;br /&gt; &lt;/p&gt; </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[185]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="186">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
      <Method id="2" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase1.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This method "String.getBytes(String)" needlessly uses a String literal to define an encoding.  A built-in Charset could be used instead like: String.getBytes(Charset)</BugMessage>
    <ResolutionSuggestion>     		     		&lt;p&gt;This method uses a string literal to specify a &lt;code&gt;Charset&lt;/code&gt; encoding. However, the method invoked has an     		alternative signature that takes a &lt;code&gt;Charset&lt;/code&gt; object. You should use this signature, as this class is compiled     		with JDK 7 (or better), and the &lt;code&gt;Charset&lt;/code&gt; in question is available as a constant from the     		&lt;code&gt;java.nio.charset.StandardCharsets&lt;/code&gt; class.&lt;/p&gt;     		&lt;p&gt;Instead of specifying "UTF-8", use &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;, for instance. An added benefit of this is     		that you will not need to catch &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt;     		     	</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[186]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="187">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase1.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1.key(byte[]): new String(byte[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[187]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="188">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[188]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="189">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase1.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1.key(byte[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[189]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="190">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[190]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="191">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase1.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase1.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[191]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="192">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase2.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase2 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[192]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="193">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase2.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[193]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="194">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABHCase2.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABHCase2.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[194]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="195">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase1 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[195]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="196">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase1.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[196]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="197">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase1.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[197]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="198">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase2.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>MALICIOUS_CODE</BugGroup>
    <BugCode>MS_FINAL_PKGPROTECT</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2.DEFAULT_ENCRYPT_KEY should be both final and package protected</BugMessage>
    <ResolutionSuggestion>   &lt;p&gt;    A mutable static field could be changed by malicious code or         by accident from another package.         The field could be made package protected and/or made final    to avoid         this vulnerability.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[198]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="199">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>MALICIOUS_CODE</BugGroup>
    <BugCode>MS_SHOULD_BE_FINAL</BugCode>
    <BugRank>16</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2.KEY isn't final but should be</BugMessage>
    <ResolutionSuggestion>     &lt;p&gt; This static field public but not final, and could be changed by malicious code or         by accident from another package.         The field could be made final to avoid         this vulnerability.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[199]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="200">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase2.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[200]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="201">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase2.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase2.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[201]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="202">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase3</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase3.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase3 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[202]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="203">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase3</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase3.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase3.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[203]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="204">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase3</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABICase3.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABICase3.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[204]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="205">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABMC1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[205]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="206">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABMC1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[206]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="207">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABMC1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[207]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="208">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABMC1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABMC1.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[208]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="209">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABPSCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABPSCase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABPSCase1 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[209]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="210">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABPSCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABPSCase1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABPSCase1.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[210]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="211">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABPSCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordABPSCase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordABPSCase1.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[211]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="212">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase1 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[212]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="213">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">toCharArray</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase1.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[213]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="214">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase1.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[214]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="215">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase1</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase1.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase1.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[215]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="216">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase2.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase2 defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[216]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="217">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">key</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase2.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <CweId>259</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>HARD_CODE_PASSWORD</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Hard coded password found</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt; Passwords should not be kept in the source code. The source code can be widely shared in an enterprise environment, and is certainly shared in open source. To be managed safely, passwords and secret keys should be stored in separate configuration files or keystores. (Hard coded keys are reported separately by &lt;i&gt;Hard Coded Key&lt;/i&gt; pattern) &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;br/&gt;  &lt;pre&gt;private String SECRET_PASSWORD = "letMeIn!";  Properties props = new Properties(); props.put(Context.SECURITY_CREDENTIALS, "p@ssw0rd");&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/259.html"&gt;CWE-259: Use of Hard-coded Password&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[217]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="218">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase2.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase2.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[218]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="219">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase2</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordBBCase2.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordBBCase2.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[219]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="220">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordCorrected</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordCorrected.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>FCBL_FIELD_COULD_BE_LOCAL</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Class org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordCorrected defines fields that are used only as locals</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;This class defines fields that are used in a local only fashion, 			specifically private fields or protected fields in final classes that are accessed 			first in each method with a store vs. a load. This field could be replaced by one 			or more local variables.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[220]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="221">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordCorrected</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordCorrected.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordCorrected.pbeKeySpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[221]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="222">
    <ClassName>org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordCorrected</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictablepbepassword/PredictablePBEPasswordCorrected.java</SourceFile>
        <StartLine>9</StartLine>
        <EndLine>9</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>URF_UNREAD_FIELD</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Unread field: org.cryptoapi.bench.predictablepbepassword.PredictablePBEPasswordCorrected.pbeParamSpec</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; This field is never read.&amp;nbsp; Consider removing it from the class.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[222]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="223">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase2.java</SourceFile>
        <StartLine>10</StartLine>
        <EndLine>10</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[223]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="224">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase2.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[223]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="225">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase2.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[223]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="226">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase2.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase2.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[223]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="227">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase4.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Dead store to seed in org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4.main(String[])</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[224]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="228">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase4.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[225]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="229">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase4.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[226]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="230">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase4.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[226]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="231">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase4.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[226]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="232">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase4.java</SourceFile>
        <StartLine>18</StartLine>
        <EndLine>18</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4.main(String[]) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[226]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="233">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABHCase4.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.predictableseeds.PredictableSeedsABHCase4.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[227]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="234">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABICase3</ClassName>
    <Methods></Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABICase3.java</SourceFile>
        <StartLine>7</StartLine>
        <EndLine>7</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>MALICIOUS_CODE</BugGroup>
    <BugCode>MS_PKGPROTECT</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.predictableseeds.PredictableSeedsABICase3.DEFAULT_SEED should be package protected</BugMessage>
    <ResolutionSuggestion>    &lt;p&gt; A mutable static field could be changed by malicious code or    by accident.    The field could be made package protected to avoid    this vulnerability.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[228]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="235">
    <ClassName>org.cryptoapi.bench.predictableseeds.PredictableSeedsABICase4</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/predictableseeds/PredictableSeedsABICase4.java</SourceFile>
        <StartLine>24</StartLine>
        <EndLine>24</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>8</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Invocation of toString on PredictableSeedsABICase4.seed in org.cryptoapi.bench.predictableseeds.PredictableSeedsABICase4.go()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[229]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="236">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[230]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="237">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
      <Method id="2" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase1.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>This method "String.getBytes(String)" needlessly uses a String literal to define an encoding.  A built-in Charset could be used instead like: String.getBytes(Charset)</BugMessage>
    <ResolutionSuggestion>     		     		&lt;p&gt;This method uses a string literal to specify a &lt;code&gt;Charset&lt;/code&gt; encoding. However, the method invoked has an     		alternative signature that takes a &lt;code&gt;Charset&lt;/code&gt; object. You should use this signature, as this class is compiled     		with JDK 7 (or better), and the &lt;code&gt;Charset&lt;/code&gt; in question is available as a constant from the     		&lt;code&gt;java.nio.charset.StandardCharsets&lt;/code&gt; class.&lt;/p&gt;     		&lt;p&gt;Instead of specifying "UTF-8", use &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;, for instance. An added benefit of this is     		that you will not need to catch &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt;     		     	</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[231]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="238">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[232]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="239">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase1.java</SourceFile>
        <StartLine>21</StartLine>
        <EndLine>21</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[233]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="240">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase2.java</SourceFile>
        <StartLine>18</StartLine>
        <EndLine>18</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[234]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="241">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase2.java</SourceFile>
        <StartLine>29</StartLine>
        <EndLine>29</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase2.go(): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[235]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="242">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase2.java</SourceFile>
        <StartLine>29</StartLine>
        <EndLine>29</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase2.go() encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[236]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="243">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase2.java</SourceFile>
        <StartLine>18</StartLine>
        <EndLine>18</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[237]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="244">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABHCase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABHCase2.java</SourceFile>
        <StartLine>31</StartLine>
        <EndLine>31</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[238]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="245">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[239]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="246">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase1.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase1.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[240]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="247">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase1.java</SourceFile>
        <StartLine>22</StartLine>
        <EndLine>22</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase1.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[241]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="248">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[242]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="249">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase1.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[243]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="250">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase2.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[244]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="251">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase2.java</SourceFile>
        <StartLine>20</StartLine>
        <EndLine>20</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[245]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="252">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase2.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[246]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="253">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase3.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[247]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="254">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase3.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase3.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[248]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="255">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase3.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase3.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[249]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="256">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase3.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[250]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="257">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABICase3.java</SourceFile>
        <StartLine>12</StartLine>
        <EndLine>12</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[251]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="258">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABMC1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[252]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="259">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABMC1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[253]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="260">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABMC1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[254]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="261">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABMCCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABMCCase1.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABMCCase1.main(String[]): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[255]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="262">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABMCCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">main</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABMCCase1.java</SourceFile>
        <StartLine>11</StartLine>
        <EndLine>11</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABMCCase1.main(String[]) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[256]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="263">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABPSCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[257]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="264">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABPSCase1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABPSCase1.go(int): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[258]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="265">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABPSCase1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABPSCase1.go(int) encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[259]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="266">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABPSCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[260]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="267">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABPSCase1.java</SourceFile>
        <StartLine>24</StartLine>
        <EndLine>24</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[261]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="268">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">&lt;init&gt;</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABSCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in new org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABSCase1(): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[262]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="269">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">&lt;init&gt;</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorABSCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method new org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorABSCase1() encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[263]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="270">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorBBCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[264]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="271">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorBBCase1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>I18N</BugGroup>
    <BugCode>DM_DEFAULT_ENCODING</BugCode>
    <BugRank>19</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Found reliance on default encoding in org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorBBCase1.go(): String.getBytes()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.  &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[265]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="272">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
      <Method id="1" primary="false">getBytes</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorBBCase1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>MDM_STRING_BYTES_ENCODING</BugCode>
    <BugRank>7</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorBBCase1.go() encodes String bytes without specifying the character encoding</BugMessage>
    <ResolutionSuggestion> 			 			&lt;p&gt;The behavior of the &lt;code&gt;String(byte[] bytes)&lt;/code&gt; and &lt;code&gt;String.getBytes()&lt;/code&gt; is undefined if the string cannot be encoded in the platform's default charset. Instead, use the &lt;code&gt;String(byte[] bytes, String encoding)&lt;/code&gt; or &lt;code&gt;String.getBytes(String encoding)&lt;/code&gt; constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.&lt;/p&gt;  			&lt;p&gt;As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid &lt;a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard"&gt;encoding charsets&lt;/a&gt;.  If you aren't sure, try "UTF-8".&lt;/p&gt;  			&lt;p&gt;&lt;b&gt;New in Java 1.7&lt;/b&gt;, you can specify an encoding from &lt;code&gt;StandardCharsets&lt;/code&gt;, like &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt;.  These are generally preferrable because you don't have to deal with &lt;code&gt;UnsupportedEncodingException&lt;/code&gt;.&lt;/p&gt; 			 		</ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[266]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="273">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorBBCase1.java</SourceFile>
        <StartLine>14</StartLine>
        <EndLine>14</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[267]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="274">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorBBCase1.java</SourceFile>
        <StartLine>18</StartLine>
        <EndLine>18</EndLine>
      </Location>
    </BugLocations>
    <CweId>329</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>STATIC_IV</BugCode>
    <BugRank>12</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>The initialization vector (IV) is not properly generated</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     Initialization vector must be regenerated for each message to be encrypted. &lt;/p&gt; &lt;p&gt;&lt;b&gt;Vulnerable Code:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; private static byte[] IV = new byte[16] {(byte)0,(byte)1,(byte)2,[...]};  public void encrypt(String message) throws Exception {      IvParameterSpec ivSpec = new IvParameterSpec(IV); [...] &lt;/pre&gt; &lt;p&gt;&lt;b&gt;Solution:&lt;/b&gt;&lt;/p&gt; &lt;p&gt; &lt;pre&gt; public void encrypt(String message) throws Exception {      byte[] iv = new byte[16];     new SecureRandom().nextBytes(iv);      IvParameterSpec ivSpec = new IvParameterSpec(iv); [...] &lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt; &lt;b&gt;References&lt;/b&gt;&lt;br/&gt; &lt;a href="http://en.wikipedia.org/wiki/Initialization_vector"&gt;Wikipedia: Initialization vector&lt;/a&gt;&lt;br/&gt; &lt;a href="http://cwe.mitre.org/data/definitions/329.html"&gt;CWE-329: Not Using a Random IV with CBC Mode&lt;/a&gt;&lt;br/&gt; &lt;a href="https://defuse.ca/cbcmodeiv.htm"&gt;Encryption - CBC Mode IV: Secret or Not?&lt;/a&gt; &lt;/p&gt;              </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[268]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="275">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorCorrected.java</SourceFile>
        <StartLine>41</StartLine>
        <EndLine>41</EndLine>
      </Location>
    </BugLocations>
    <CweId>353</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>CIPHER_INTEGRITY</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher does not provide data integrity</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     The ciphertext produced is susceptible to alteration by an adversary. This mean that the cipher provides no way to detect that the      data has been tampered with. If the ciphertext can be controlled by an attacker, it could be altered without detection. &lt;/p&gt; &lt;p&gt;     The solution is to use a cipher that includes a Hash based Message Authentication Code (HMAC) to sign the data. Combining a HMAC function to the     existing cipher is prone to error &lt;sup&gt;&lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Specifically,     it is always recommended that you be able to verify the HMAC first, and only if the data is unmodified, do you then perform any cryptographic     functions on the data. &lt;/p&gt; &lt;p&gt;The following modes are vulnerable because they don't provide a HMAC:&lt;br/&gt;     - CBC&lt;br/&gt;     - OFB&lt;br/&gt;     - CTR&lt;br/&gt;     - ECB&lt;br/&gt;&lt;br/&gt;     The following snippets code are some examples of vulnerable code.&lt;br/&gt;&lt;br/&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;&lt;br/&gt;     &lt;i&gt;AES in CBC mode&lt;/i&gt;&lt;br/&gt;      &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt;     &lt;br/&gt;     &lt;i&gt;Triple DES with ECB mode&lt;/i&gt;&lt;br/&gt;  &lt;pre&gt;Cipher c = Cipher.getInstance("DESede/ECB/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt; In the example solution above, the GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result. &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/"&gt;Moxie Marlinspike's blog: The Cryptographic Doom Principle&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/353.html"&gt;CWE-353: Missing Support for Integrity Check&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[269]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="276">
    <ClassName>org.cryptoapi.bench.staticinitializationvector.StaticInitializationVectorCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">go</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticinitializationvector/StaticInitializationVectorCorrected.java</SourceFile>
        <StartLine>41</StartLine>
        <EndLine>41</EndLine>
      </Location>
    </BugLocations>
    <CweId>326</CweId>
    <BugGroup>SECURITY</BugGroup>
    <BugCode>PADDING_ORACLE</BugCode>
    <BugRank>10</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>The cipher is susceptible to padding oracle attacks</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;     This specific mode of CBC with PKCS5Padding is susceptible to padding oracle attacks. An adversary could potentially decrypt the     message if the system exposed the difference between plaintext with invalid padding or valid padding. The distinction between     valid and invalid padding is usually revealed through distinct error messages being returned for each condition. &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Code at risk:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;p&gt;     &lt;b&gt;Solution:&lt;/b&gt;     &lt;pre&gt;Cipher c = Cipher.getInstance("AES/GCM/NoPadding"); c.init(Cipher.ENCRYPT_MODE, k, iv); byte[] cipherText = c.doFinal(plainText);&lt;/pre&gt; &lt;/p&gt; &lt;br/&gt; &lt;p&gt;     &lt;b&gt;References&lt;/b&gt;&lt;br/&gt;     &lt;a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf"&gt;Padding Oracles for the masses (by Matias Soler)&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://en.wikipedia.org/wiki/Authenticated_encryption"&gt;Wikipedia: Authenticated encryption&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01"&gt;NIST: Authenticated Encryption Modes&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://capec.mitre.org/data/definitions/463.html"&gt;CAPEC: Padding Oracle Crypto Attack&lt;/a&gt;&lt;br/&gt;     &lt;a href="http://cwe.mitre.org/data/definitions/696.html"&gt;CWE-696: Incorrect Behavior Order&lt;/a&gt; &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[270]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="277">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[271]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="278">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2() invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[272]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="279">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2() invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[272]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="280">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2() invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[272]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="281">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
      <Method id="1" primary="false">&lt;init&gt;</Method>
      <Method id="2" primary="false">valueOf</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>18</StartLine>
        <EndLine>18</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>PERFORMANCE</BugGroup>
    <BugCode>DM_NUMBER_CTOR</BugCode>
    <BugRank>18</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2() invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead</BugMessage>
    <ResolutionSuggestion>              &lt;p&gt;       Using &lt;code&gt;new Integer(int)&lt;/code&gt; is guaranteed to always result in a new object whereas       &lt;code&gt;Integer.valueOf(int)&lt;/code&gt; allows caching of values to be done by the compiler, class library, or JVM.       Using of cached values avoids object allocation and the code will be faster.       &lt;/p&gt;       &lt;p&gt;       Values between -128 and 127 are guaranteed to have corresponding cached instances       and using &lt;code&gt;valueOf&lt;/code&gt; is approximately 3.5 times faster than using constructor.       For values outside the constant range the performance of both styles is the same.       &lt;/p&gt;       &lt;p&gt;       Unless the class must be compatible with JVMs predating Java 1.5,       use either autoboxing or the &lt;code&gt;valueOf()&lt;/code&gt; method when creating instances of       &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, and &lt;code&gt;Byte&lt;/code&gt;.       &lt;/p&gt;        </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[272]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="282">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>25</StartLine>
        <EndLine>25</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>UC_USELESS_OBJECT</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Useless object stored in variable pbeParamSpec of method org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt;Our analysis shows that this object is useless. It's created and modified, but its value never go outside of the method or produce any side-effect. Either there is a mistake and object was intended to be used or it can be removed.&lt;/p&gt; &lt;p&gt;This analysis rarely produces false-positives. Common false-positive cases include:&lt;/p&gt; &lt;p&gt;- This object used to implicitly throw some obscure exception.&lt;/p&gt; &lt;p&gt;- This object used as a stub to generalize the code.&lt;/p&gt; &lt;p&gt;- This object used to hold strong references to weak/soft-referenced objects.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[273]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="283">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>23</StartLine>
        <EndLine>23</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>UC_USELESS_OBJECT</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Useless object stored in variable salt of method org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt;Our analysis shows that this object is useless. It's created and modified, but its value never go outside of the method or produce any side-effect. Either there is a mistake and object was intended to be used or it can be removed.&lt;/p&gt; &lt;p&gt;This analysis rarely produces false-positives. Common false-positive cases include:&lt;/p&gt; &lt;p&gt;- This object used to implicitly throw some obscure exception.&lt;/p&gt; &lt;p&gt;- This object used as a stub to generalize the code.&lt;/p&gt; &lt;p&gt;- This object used to hold strong references to weak/soft-referenced objects.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[274]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="284">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABHCase1.java</SourceFile>
        <StartLine>26</StartLine>
        <EndLine>26</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>UC_USELESS_VOID_METHOD</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticsalts.StaticSaltsABHCase1.key2() seems to be useless</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt;Our analysis shows that this non-empty void method does not actually perform any useful work. Please check it: probably there's a mistake in its code or its body can be fully removed. &lt;/p&gt; &lt;p&gt;We are trying to reduce the false positives as much as possible, but in some cases this warning might be wrong. Common false-positive cases include:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;The method is intended to trigger loading of some class which may have a side effect.&lt;/li&gt; &lt;li&gt;The method is intended to implicitly throw some obscure exception.&lt;/li&gt; &lt;/ul&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[275]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="285">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABICase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABICase1.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsABICase1.key2(byte[], int)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[276]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="286">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABICase2.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsABICase2.key2(int)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[277]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="287">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABICase2.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>CORRECTNESS</BugGroup>
    <BugCode>DMI_INVOKING_TOSTRING_ON_ARRAY</BugCode>
    <BugRank>8</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Invocation of toString on StaticSaltsABICase2.salt in org.cryptoapi.bench.staticsalts.StaticSaltsABICase2.key2(int)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[278]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="288">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABICase2</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABICase2.java</SourceFile>
        <StartLine>27</StartLine>
        <EndLine>27</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>UC_USELESS_OBJECT</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Useless object stored in variable pbeParamSpec of method org.cryptoapi.bench.staticsalts.StaticSaltsABICase2.key2(int)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt;Our analysis shows that this object is useless. It's created and modified, but its value never go outside of the method or produce any side-effect. Either there is a mistake and object was intended to be used or it can be removed.&lt;/p&gt; &lt;p&gt;This analysis rarely produces false-positives. Common false-positive cases include:&lt;/p&gt; &lt;p&gt;- This object used to implicitly throw some obscure exception.&lt;/p&gt; &lt;p&gt;- This object used as a stub to generalize the code.&lt;/p&gt; &lt;p&gt;- This object used to hold strong references to weak/soft-referenced objects.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[279]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="289">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABICase3</ClassName>
    <Methods>
      <Method id="0" primary="true">method2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABICase3.java</SourceFile>
        <StartLine>18</StartLine>
        <EndLine>18</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsABICase3.method2(byte[], int)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[280]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="290">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABMC1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABMC1.java</SourceFile>
        <StartLine>8</StartLine>
        <EndLine>8</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsABMC1.key2(byte[], int)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[281]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="291">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsABPSCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsABPSCase1.java</SourceFile>
        <StartLine>19</StartLine>
        <EndLine>19</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsABPSCase1.key2(int)</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[282]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="292">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsBBCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1.key2()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[283]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="293">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsBBCase1.java</SourceFile>
        <StartLine>15</StartLine>
        <EndLine>15</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>UC_USELESS_OBJECT</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Useless object stored in variable pbeParamSpec of method org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1.key2()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt;Our analysis shows that this object is useless. It's created and modified, but its value never go outside of the method or produce any side-effect. Either there is a mistake and object was intended to be used or it can be removed.&lt;/p&gt; &lt;p&gt;This analysis rarely produces false-positives. Common false-positive cases include:&lt;/p&gt; &lt;p&gt;- This object used to implicitly throw some obscure exception.&lt;/p&gt; &lt;p&gt;- This object used as a stub to generalize the code.&lt;/p&gt; &lt;p&gt;- This object used to hold strong references to weak/soft-referenced objects.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[284]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="294">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsBBCase1.java</SourceFile>
        <StartLine>13</StartLine>
        <EndLine>13</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>UC_USELESS_OBJECT</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Useless object stored in variable salt of method org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1.key2()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt;Our analysis shows that this object is useless. It's created and modified, but its value never go outside of the method or produce any side-effect. Either there is a mistake and object was intended to be used or it can be removed.&lt;/p&gt; &lt;p&gt;This analysis rarely produces false-positives. Common false-positive cases include:&lt;/p&gt; &lt;p&gt;- This object used to implicitly throw some obscure exception.&lt;/p&gt; &lt;p&gt;- This object used as a stub to generalize the code.&lt;/p&gt; &lt;p&gt;- This object used to hold strong references to weak/soft-referenced objects.&lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[285]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="295">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsBBCase1.java</SourceFile>
        <StartLine>16</StartLine>
        <EndLine>16</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>UC_USELESS_VOID_METHOD</BugCode>
    <BugRank>17</BugRank>
    <BugSeverity>2</BugSeverity>
    <BugMessage>Method org.cryptoapi.bench.staticsalts.StaticSaltsBBCase1.key2() seems to be useless</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt;Our analysis shows that this non-empty void method does not actually perform any useful work. Please check it: probably there's a mistake in its code or its body can be fully removed. &lt;/p&gt; &lt;p&gt;We are trying to reduce the false positives as much as possible, but in some cases this warning might be wrong. Common false-positive cases include:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;The method is intended to trigger loading of some class which may have a side effect.&lt;/li&gt; &lt;li&gt;The method is intended to implicitly throw some obscure exception.&lt;/li&gt; &lt;/ul&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[286]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugInstance id="296">
    <ClassName>org.cryptoapi.bench.staticsalts.StaticSaltsCorrected</ClassName>
    <Methods>
      <Method id="0" primary="true">key2</Method>
    </Methods>
    <BugLocations>
      <Location id="0" primary="true">
        <SourceFile>pkg1/CryptoAPI-Bench-1/src/main/java/org/cryptoapi/bench/staticsalts/StaticSaltsCorrected.java</SourceFile>
        <StartLine>17</StartLine>
        <EndLine>17</EndLine>
      </Location>
    </BugLocations>
    <BugGroup>STYLE</BugGroup>
    <BugCode>DLS_DEAD_LOCAL_STORE</BugCode>
    <BugRank>15</BugRank>
    <BugSeverity>1</BugSeverity>
    <BugMessage>Dead store to pbeParamSpec in org.cryptoapi.bench.staticsalts.StaticSaltsCorrected.key2()</BugMessage>
    <ResolutionSuggestion>  &lt;p&gt; This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. &lt;/p&gt; &lt;p&gt; Note that Sun's javac compiler often generates dead stores for final local variables.  Because SpotBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. &lt;/p&gt;  </ResolutionSuggestion>
    <BugTrace>
      <BuildId>1</BuildId>
      <AssessmentReportFile>assessment_report1.xml</AssessmentReportFile>
      <InstanceLocation>
        <Xpath>/BugCollection/BugInstance[287]</Xpath>
      </InstanceLocation>
    </BugTrace>
  </BugInstance>
  <BugSummary>
    <BugCategory group="PERFORMANCE" code="PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS" count="5" bytes="8142" />
    <BugCategory group="PERFORMANCE" code="URF_UNREAD_FIELD" count="20" bytes="22488" />
    <BugCategory group="PERFORMANCE" code="DM_NUMBER_CTOR" count="12" bytes="27376" />
    <BugCategory group="PERFORMANCE" code="DM_STRING_CTOR" count="6" bytes="8738" />
    <BugCategory group="I18N" code="DM_DEFAULT_ENCODING" count="43" bytes="63623" />
    <BugCategory group="MALICIOUS_CODE" code="MS_FINAL_PKGPROTECT" count="1" bytes="1310" />
    <BugCategory group="MALICIOUS_CODE" code="MS_PKGPROTECT" count="1" bytes="1185" />
    <BugCategory group="MALICIOUS_CODE" code="MS_SHOULD_BE_FINAL" count="1" bytes="1263" />
    <BugCategory group="STYLE" code="IMC_IMMATURE_CLASS_PRINTSTACKTRACE" count="1" bytes="1319" />
    <BugCategory group="STYLE" code="UC_USELESS_OBJECT" count="5" bytes="8271" />
    <BugCategory group="STYLE" code="DLS_DEAD_LOCAL_STORE" count="18" bytes="26960" />
    <BugCategory group="STYLE" code="UC_USELESS_VOID_METHOD" count="2" bytes="3235" />
    <BugCategory group="SECURITY" code="WEAK_MESSAGE_DIGEST_MD5" count="6" bytes="32647" />
    <BugCategory group="SECURITY" code="CIPHER_INTEGRITY" count="30" bytes="108819" />
    <BugCategory group="SECURITY" code="DES_USAGE" count="3" bytes="5720" />
    <BugCategory group="SECURITY" code="PADDING_ORACLE" count="17" bytes="44674" />
    <BugCategory group="SECURITY" code="WEAK_MESSAGE_DIGEST_SHA1" count="2" bytes="10496" />
    <BugCategory group="SECURITY" code="HARD_CODE_PASSWORD" count="16" bytes="28753" />
    <BugCategory group="SECURITY" code="STATIC_IV" count="8" bytes="17423" />
    <BugCategory group="SECURITY" code="ECB_MODE" count="4" bytes="10706" />
    <BugCategory group="SECURITY" code="URLCONNECTION_SSRF_FD" count="9" bytes="30838" />
    <BugCategory group="CORRECTNESS" code="BED_BOGUS_EXCEPTION_DECLARATION" count="1" bytes="1628" />
    <BugCategory group="CORRECTNESS" code="DMI_INVOKING_TOSTRING_ON_ARRAY" count="28" bytes="39644" />
    <BugCategory group="CORRECTNESS" code="CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET" count="5" bytes="10214" />
    <BugCategory group="CORRECTNESS" code="FCBL_FIELD_COULD_BE_LOCAL" count="10" bytes="13546" />
    <BugCategory group="CORRECTNESS" code="MDM_STRING_BYTES_ENCODING" count="43" bytes="97118" />
  </BugSummary>
</AnalyzerReport>